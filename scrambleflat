#!/usr/bin/python
"""
    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>

= Description

Scramble a file

= Notes:

Website: https://github.com/samyboy/scrambleflat

This file tends to be PEP-8 compliant. Use these commands to be
proud of your work:

* using pep8:

  pep8 --show-source --show-pep8 scramble

* using pyling:

  pylint --report=n scramble

"""

#import os
#import re
import sys
import argparse

__version__ = '0'
__author__ = 'Samuel Krieg'


class Scrambler:
    """ A nice dsecription goes here
    """

    def __init__(self):
        self.dictionnary = {}

    def build_dictionnary(self, fichiers):
        """Creates a dictionnary of terms to hide
        """
        for fichier in fichiers:
            num = 1
            for line in fichier:
                line = line.strip()
                if line != '':
                    cle = line
                    self.dictionnary[cle] = fichier.name + str(num)
                num += 1

    def strtr(self, strng):
        """Search and replace
           Source: http://stackoverflow.com/a/10931514/238913
        """
        # pylint: disable-msg=C0103
        buff = []
        i, n = 0, len(strng)
        while i < n:
            # pour chaque lettre
            match = False
            for s, r in self.dictionnary.items():
                if strng[i:len(s) + i] == s:
                    buff.append(r)
                    i = i + len(s)
                    match = True
                    break
            if not match:
                buff.append(strng[i])
                i = i + 1
        return ''.join(buff)

    def scramble(self, line):
        """do the scramble for one line
        """
        return self.strtr(line)


def parse_arguments():
    """Try to parse the command line arguments given by the user"""
    # pylint: disable-msg=C0103

    version_string = "%(prog)s-%(version)s by %(author)s" % \
                     {"prog": "%(prog)s", "version": __version__, \
                     "author": __author__}

    p = argparse.ArgumentParser(description="Scrambles a flat file",
        formatter_class=argparse.RawDescriptionHelpFormatter)
    p.add_argument('-V', '--version', action='version',
                   help="shows program version", version=version_string)
    p.add_argument('-i', '--infile', nargs='?', type=argparse.FileType('r'),
                   default=sys.stdin,
                   help='the source file to scramble')
    p.add_argument('-o', '--outfile', nargs='?', type=argparse.FileType('w'),
                   default=sys.stdout,
                   help='the scrambled file')
    p.add_argument('-t', '--terms', nargs='+', required=True,
                   type=argparse.FileType('r'),
                   help='the file that contains all the terms that must be \
                   scrambled. Each term is replaced by the concatenation of \
                   the file name provided by --terms and its line number \
                   in the input file.')
    return p.parse_args()


def main():
    """the main function
    """

    # get the arguments
    args = parse_arguments()

    scrambler = Scrambler()
    scrambler.build_dictionnary(args.terms)
    for line in args.infile:
        args.outfile.write(scrambler.scramble(line))

if __name__ == '__main__':
    main()

### EOF ###
